namespace {{node.property.namespace}} {

#define FRPC_ERROR_FORMAT(message) [] (const std::string& info) { std::stringstream ss; ss << __FILE__ << ":" << __LINE__ << " " << info ; return ss.str(); } (message)

template <class TObject>
inline msgpack::sbuffer pack(const TObject& object) {
    msgpack::sbuffer buffer;
    msgpack::pack(buffer, object);
    return buffer;
}

template <class TObject>
inline TObject unpack(const void* data, size_t size) {
    auto handle = msgpack::unpack(reinterpret_cast<const char*>(data), size);
    auto value = handle.get().as<TObject>();
    return value;
}

template <typename T>
T fromString(const std::string&);

template <typename T>
inline std::enable_if_t<std::is_arithmetic<T>::value && !std::is_same<T, bool>::value, std::string> toString(T value) {
    return std::to_string(value);
}

inline std::string toString(bool value) {
    return value ? "true" : "false";
}

inline std::string toString(const std::string& value) {
    return value;
}

template <typename T>
inline std::string toString(const std::vector<T>& vector) {
    std::string str = "[";
    auto it = vector.begin();
    if (it != vector.end()) {
        str += toString(*it);
        ++it;
    }
    for (; it != vector.end(); ++it) {
        str += ",";
        str += toString(*it);
    }
    str += "]";
    return str;
}

template <typename K, typename V>
inline std::string toString(const std::unordered_map<K, V>& map) {
    std::string str = "{";
    auto it = map.begin();
    if (it != map.end()) {
        str += toString(it->first);
        str += "->";
        str += toString(it->second);
        ++it;
    }
    for (; it != map.end(); ++it) {
        str += ",";
        str += toString(it->first);
        str += "->";
        str += toString(it->second);
    }
    str += "}";
    return str;
}

inline std::string uuid() {
    uuid_t uuid;
    char uuid_str[37];
    uuid_generate_random(uuid);
    uuid_unparse(uuid, uuid_str);
    return std::string(uuid_str);
}

struct ChannelConfig {
    std::size_t io_threads{1};
    zmq::socket_type socktype{zmq::socket_type::dealer};
    int32_t sendhwm{0};
    int32_t recvhwm{0};
    int32_t sendbuf{0};
    int32_t recvbuf{0};
    int32_t linger{2000};
    std::string addr{"tcp://127.0.0.1:5833"};
    bool bind{false};
    bool mandatory{false};
    bool tcp_keepalive{true};
    int tcp_keepalive_idle{60};
    int tcp_keepalive_cnt{3};
    int tcp_keepalive_intvl{5};
    bool probe{false};
    int16_t context_pool_size{1};
    std::size_t channel_size{50000};
};

inline std::string uniqueAddr() {
    uuid_t uuid;
    char s[37];
    uuid_generate_random(uuid);
    uuid_unparse(uuid, s);
    return "inproc://" + std::string(s);
}

template <typename>
struct Stream;

template <typename R, typename... Args>
struct Stream<R(Args...)> : std::function<R(Args...)> {
    template <typename F>
    Stream(F&& func, std::function<void()>&& close)
        : std::function<R(Args...)>(std::forward<F>(func)), m_close(std::move(close)) {
    }
    Stream(const Stream&) = delete;
    Stream(Stream&&) = default;
    Stream& operator=(const Stream&) = delete;
    Stream& operator=(Stream&&) = default;

    ~Stream() {
        if (m_close) {
            m_close();
        }
    }

    void close() {
        if (m_close) {
            m_close();
        }
        m_close = nullptr;
    }

private:
    std::function<void()> m_close;
};

template <typename T>
class MpscQueue {
public:
    MpscQueue()
        : head_(new BufferNode)
        , tail_(head_.load(std::memory_order_relaxed)) {
    }
    ~MpscQueue() {
        T output;
        while (this->dequeue(output)) {
        }
        BufferNode* front = head_.load(std::memory_order_relaxed);
        delete front;
    }

    void enqueue(T&& input) {
        BufferNode* node{new BufferNode(std::move(input))};
        BufferNode* prevhead{head_.exchange(node, std::memory_order_acq_rel)};
        prevhead->next_.store(node, std::memory_order_release);
    }
    void enqueue(const T& input) {
        BufferNode* node{new BufferNode(input)};
        BufferNode* prevhead{head_.exchange(node, std::memory_order_acq_rel)};
        prevhead->next_.store(node, std::memory_order_release);
    }

    bool dequeue(T& output) {
        BufferNode* tail = tail_.load(std::memory_order_relaxed);
        BufferNode* next = tail->next_.load(std::memory_order_acquire);

        if (next == nullptr) {
            return false;
        }
        output = std::move(*(next->dataPtr_));
        delete next->dataPtr_;
        tail_.store(next, std::memory_order_release);
        delete tail;
        return true;
    }

    bool empty() {
        BufferNode* tail = tail_.load(std::memory_order_relaxed);
        BufferNode* next = tail->next_.load(std::memory_order_acquire);
        return next == nullptr;
    }

private:
    struct BufferNode {
        BufferNode() = default;
        BufferNode(const T& data)
            : dataPtr_(new T(data)) {
        }
        BufferNode(T&& data)
            : dataPtr_(new T(std::move(data))) {
        }
        T* dataPtr_;
        std::atomic<BufferNode*> next_{nullptr};
    };

    std::atomic<BufferNode*> head_;
    std::atomic<BufferNode*> tail_;
};

} // {{node.property.namespace}}
