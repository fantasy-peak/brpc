#ifndef _{{upper(value.property.namespace)}}_{{upper(_snake(value.struct_name))}}_H_
#define _{{upper(value.property.namespace)}}_{{upper(_snake(value.struct_name))}}_H_

namespace {{value.property.namespace}} {

struct {{value.struct_name}} {
    {% for field in value.definitions %}
        {{field.type}} {{_snake(field.name)}}; // {{field.comment}}
    {% endfor %}

    MSGPACK_DEFINE({{_join(value.definitions)}})
};

NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE({{value.struct_name}}, {{_join(value.definitions)}})

inline std::string toString(const {{value.struct_name}}& value) {
    std::ostringstream ss;
    {% for field in value.definitions %}
        {% if loop.is_first %}
            {% if _is_fundamental(field.type) == true %}
                ss << "{{value.struct_name}}{" << value.{{_snake(field.name)}}
            {% else %}
                ss << "{{value.struct_name}}{" << toString(value.{{_snake(field.name)}})
            {% endif  %}
        {% else %}
            {% if _is_fundamental(field.type) == true %}
                << "," << value.{{_snake(field.name)}}
            {% else %}
                << "," << toString(value.{{_snake(field.name)}})
            {% endif  %}
        {% endif  %}
    {% endfor %}
    << "}";
    return ss.str();
}

inline bool operator==(const {{value.struct_name}}& lhs, const {{value.struct_name}}& rhs) {
    return 
    {% for field in value.definitions %}
        {% if loop.is_first %}
            (lhs.{{_snake(field.name)}} == rhs.{{_snake(field.name)}})
        {% else %}
            &&
            (lhs.{{_snake(field.name)}} == rhs.{{_snake(field.name)}})
        {% endif  %}
    {% endfor %}
    ;
}

inline bool operator!=(const {{value.struct_name}}& lhs, const {{value.struct_name}}& rhs) {
    return !(lhs == rhs);
}

} // {{value.property.namespace}}

#endif // _{{upper(value.property.namespace)}}_{{upper(_snake(value.struct_name))}}_H_
