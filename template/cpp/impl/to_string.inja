#ifndef _{{upper(node.property.namespace)}}_TO_STRING_H_
#define _{{upper(node.property.namespace)}}_TO_STRING_H_

namespace {{node.property.namespace}} {

template <typename T>
T fromString(const std::string&);

template <typename T>
inline std::enable_if_t<std::is_arithmetic<T>::value && !std::is_same<T, bool>::value, std::string> toString(T value) {
    return std::to_string(value);
}

inline std::string toString(bool value) {
    return value ? "true" : "false";
}

inline std::string toString(const std::string& value) {
    return value;
}

template <typename T>
inline std::string toString(const std::vector<T>& vector) {
    std::string str = "[";
    auto it = vector.begin();
    if (it != vector.end()) {
        str += toString(*it);
        ++it;
    }
    for (; it != vector.end(); ++it) {
        str += ",";
        str += toString(*it);
    }
    str += "]";
    return str;
}

template <typename K, typename V>
inline std::string toString(const std::unordered_map<K, V>& map) {
    std::string str = "{";
    auto it = map.begin();
    if (it != map.end()) {
        str += toString(it->first);
        str += "->";
        str += toString(it->second);
        ++it;
    }
    for (; it != map.end(); ++it) {
        str += ",";
        str += toString(it->first);
        str += "->";
        str += toString(it->second);
    }
    str += "}";
    return str;
}

} // {{node.property.namespace}}

#endif //_{{upper(node.property.namespace)}}_TO_STRING_H_
