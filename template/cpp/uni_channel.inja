namespace {{node.property.namespace}} {

struct UniChannel final {
public:
    UniChannel(const ChannelConfig& config,
               std::function<void(std::vector<zmq::message_t>&)> cb,
               std::function<void(std::string)> error)
        : m_context(std::make_shared<zmq::context_t>(config.io_threads))
        , m_socket(*m_context, config.socktype)
        , m_cb(std::move(cb))
        , m_error(std::move(error)) {
        m_socket.set(zmq::sockopt::sndhwm, config.sendhwm);
        m_socket.set(zmq::sockopt::rcvhwm, config.recvhwm);
        m_socket.set(zmq::sockopt::sndbuf, config.sendbuf);
        m_socket.set(zmq::sockopt::rcvbuf, config.recvbuf);
        m_socket.set(zmq::sockopt::linger, config.linger);
        if (config.tcp_keepalive) {
            m_socket.set(zmq::sockopt::tcp_keepalive, 1);
            m_socket.set(zmq::sockopt::tcp_keepalive_idle, config.tcp_keepalive_idle);
            m_socket.set(zmq::sockopt::tcp_keepalive_cnt, config.tcp_keepalive_cnt);
            m_socket.set(zmq::sockopt::tcp_keepalive_intvl, config.tcp_keepalive_intvl);
        }
        if (config.socktype == zmq::socket_type::sub)
            m_socket.set(zmq::sockopt::subscribe, "");
        if (config.bind)
            m_socket.bind(config.addr);
        else
            m_socket.connect(config.addr);
    }

    UniChannel(std::shared_ptr<zmq::context_t> context,
                const ChannelConfig& config,
                std::function<void(std::vector<zmq::message_t>&)> cb,
                std::function<void(std::string)> error)
        : m_context(std::move(context))
        , m_socket(*m_context, config.socktype)
        , m_cb(std::move(cb))
        , m_error(std::move(error)) {
        m_socket.set(zmq::sockopt::sndhwm, config.sendhwm);
        m_socket.set(zmq::sockopt::rcvhwm, config.recvhwm);
        m_socket.set(zmq::sockopt::sndbuf, config.sendbuf);
        m_socket.set(zmq::sockopt::rcvbuf, config.recvbuf);
        m_socket.set(zmq::sockopt::linger, config.linger);
        if (config.tcp_keepalive) {
            m_socket.set(zmq::sockopt::tcp_keepalive, 1);
            m_socket.set(zmq::sockopt::tcp_keepalive_idle, config.tcp_keepalive_idle);
            m_socket.set(zmq::sockopt::tcp_keepalive_cnt, config.tcp_keepalive_cnt);
            m_socket.set(zmq::sockopt::tcp_keepalive_intvl, config.tcp_keepalive_intvl);
        }
        if (config.socktype == zmq::socket_type::sub)
            m_socket.set(zmq::sockopt::subscribe, "");
        if (config.bind)
            m_socket.bind(config.addr);
        else
            m_socket.connect(config.addr);
    }

    ~UniChannel() {
        m_running = false;
        if (m_thread.joinable())
            m_thread.join();
    }

    void start() {
        m_running = true;
        m_thread = std::thread([this] {
            std::vector<zmq::pollitem_t> items{
                {static_cast<void*>(m_socket), 0, ZMQ_POLLIN | ZMQ_POLLERR, 0},
            };
            std::chrono::milliseconds interval(200);
            while (m_running.load()) {
                zmq::poll(items, interval);
                if (items[0].revents & ZMQ_POLLIN) {
                    std::vector<zmq::message_t> recv_msgs;
                    auto ret = zmq::recv_multipart(m_socket, std::back_inserter(recv_msgs));
                    if (!ret) {
                        m_error("zmq::recv_multipart error!!!");
                        break;
                    }
                    m_cb(recv_msgs);
                }
            }
        });
    }

    auto& context() {
        return *m_context;
    }

    auto& socket() {
        return m_socket;
    }

private:
    std::shared_ptr<zmq::context_t> m_context;
    zmq::socket_t m_socket;
    std::function<void(std::vector<zmq::message_t>&)> m_cb;
    std::function<void(std::string)> m_error;
    std::atomic_bool m_running;
    std::thread m_thread;
};

} // {{node.property.namespace}}
